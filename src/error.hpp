#ifndef ERROR_H
#define ERROR_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "lexer.hpp"

enum ErrorCode {
  // parser.
  P_NO_MATCH,
  P_FIELD_NO_EXPR,
  P_FIELD_NO_LINESTOP,
  P_TARGET_NO_ITERATOR,
  P_TARGET_NO_OPEN,
  P_TARGET_NO_CLOSE,
  P_AST_INVALID_END,
  P_AST_NO_ARROW,
  P_AST_INVALID_REPLACE,
  P_AST_INVALID_ESCAPE,
  P_AST_NO_CLOSE,

  // interpreter.
  I_NO_MATCHING_IDENTIFIER,
  I_CONSTRUCTOR_EXPECTED_LITERAL,
  I_CONSTRUCTOR_EXPECTED_BOOL,
  I_CONSTRUCTOR_EXPECTED_NONEMPTY,
  I_EVALUATE_EXPECTED_NONEMPTY,
  I_EVALUATE_QBSTRING_IN_QBBOOL_LIST,
  I_EVALUATE_QBBOOL_IN_QBSTRING_LIST,
  I_EVALUATE_LIST_TYPE_MISMATCH,
  I_EVALUATE_REPLACE_TYPE_ERROR,
  I_REPLACE_CHUNKS_LENGTH_ERROR,
  I_NO_FIELD_NOR_DEFAULT,
  I_TYPE_DEPENDENCIES,
  I_TYPE_RUN,
  I_TYPE_PARALLEL,
  I_NONZERO_PROCESS,
  I_SPECIFIED_TARGET_NOT_FOUND,
  I_NO_TARGETS,
  I_MULTIPLE_TARGETS,
  I_BUILD_FAILED,

  // lexer.
  L_INVALID_SYMBOL,
  L_INVALID_LITERAL,
};

struct ErrorInfo {
  Origin origin;        // where the error originated in the ascii stream.
  ErrorCode error_code; // enum variant.
  std::string message;  // generated by table below.
};

// error code: <message, description>
const std::map<ErrorCode, std::string> _ERROR_LOOKUP_TABLE = {
    {P_NO_MATCH,
     "An invalid expression was encountered and couldn't be parsed. Are "
     "you trying to declare a field or a target?"},
    {P_FIELD_NO_EXPR,
     "An invalid expression was encountered while parsing a field."},
    {P_FIELD_NO_LINESTOP, "Expected a semicolon, but none was ncountered."},
    {P_TARGET_NO_ITERATOR, "Encountered an explicitly declared iterator, but "
                           "no iteration variable was found."},
    {P_TARGET_NO_OPEN, "Expected an opening curly bracket, but none was "
                       "encountered. Are you trying to declare a target?"},
    {P_TARGET_NO_CLOSE, "Expected a closing curly bracket but none was "
                        "encountered. Are you trying to declare a field?"},
    {P_AST_INVALID_END, "Encountered a list of expressions but one or more "
                        "elements were invalid."},
    {P_AST_NO_ARROW,
     "Encountered a replacement operator, but no replacement arrow was found."},
    {P_AST_INVALID_REPLACE,
     "Encountered a replacement operator, but the expressions were invalid."},
    {P_AST_INVALID_ESCAPE, "Encountered an escaped literal but the escaped "
                           "expressions were invalid."},
    {P_AST_NO_CLOSE,
     "Expected a closing square bracket, but none was encountered."},
    {L_INVALID_SYMBOL,
     "Encountered an invalid symbol and couldn't recover. Make sure no "
     "erroneous characters are present in the config."},
    {L_INVALID_LITERAL,
     "An expression inside of an escaped literal is invalid and couldn't "
     "be lexed. Make sure the expression is correct."},

    {I_NO_FIELD_NOR_DEFAULT, "A required field was not present."},
    {I_TYPE_DEPENDENCIES,
     "Encountered an incorrect type while evaluating a field. Make sure that "
     "the dependency field only contains one or more strings."},
    {I_TYPE_RUN,
     "Encountered an incorrect type while evaluating a field. Make sure that "
     "the run field only contains one or more strings."},
    {I_TYPE_PARALLEL,
     "Encountered an incorrect type while evaluating a field. Make sure that "
     "the parallel specifier only contains a single boolean."},
    {I_NONZERO_PROCESS,
     "A task failed to execute as a process returned a non-zero exit value."},
    {I_SPECIFIED_TARGET_NOT_FOUND,
     "The user-specified task does not exist."},
    {I_NO_TARGETS,
     "No tasks were declared."},
    {I_MULTIPLE_TARGETS,
     "No task was specified and the implicit default is ambiguous."},
    {I_BUILD_FAILED,
     "Requirements for building task were not met."},

};

class ErrorHandler {
private:
  static std::vector<ErrorInfo> error_stack;

public:
  static void push_error(Origin origin, ErrorCode error_code);
  static void push_error_throw(Origin origin, ErrorCode error_code);
  static std::optional<ErrorInfo> pop_error();
};

class BuildException : public std::exception {
private:
  const char *details;

public:
  BuildException(const char *details) : details(details) {}
  const char *what() const noexcept override { return details; };
};

#endif
